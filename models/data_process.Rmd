---
title: "Model Simulations"
author: "Ben Peloquin"
date: "April 7, 2016"
output:
  html_document:
    toc: true
---

# Prelim set-up
```{r}
rm(list = ls())
```

```{r}
source("matrices.R")
library(rrrsa)
library(dplyr)
library(tidyr)
library(ggplot2)
```

## Generic helpers
```{r}
#####
##### normalizeBy()
##### -------------
##### normaze matrix by rows or cols, maintain naming
#####
normalizeBy <- function(m, rows = TRUE) {
  colNames <- colnames(m)
  rowNames <- rownames(m)
  normedM <- t(apply(m, MARGIN = ifelse(rows, 1, 2), rrrsa::rsa.normVec))
  colnames(normedM) <- colNames
  rownames(normedM) <- rowNames
  normedM
}

#####
##### inGlobalEnv()
##### -------------
##### boolean object presence in global env
#####
inGlobalEnv <- function(item) {
  item %in% ls(envir = .GlobalEnv)
}

#####
##### getLiteralSemantics()
##### ---------------------
##### literal semantics mapper between 
##### normalized matrices and dataframe
##### called in mutate() within dplyr chain
#####
getLiteralSemantics <- function(matrixName, object, query) {
  if (!(inGlobalEnv("simpleM") | inGlobalEnv("complexM") | inGlobalEnv("oddmanM") | inGlobalEnv("twinsM"))) {
    stop("Missing normalized matrices, please run data pre-processing block")
  }
  
  if (matrixName == "simple") {
    simpleM[as.character(object), as.character(query)]
  } else if (matrixName == "complex") {
    complexM[as.character(object), as.character(query)]
  } else if (matrixName == "oddman") {
    oddmanM[as.character(object), as.character(query)]
  } else if (matrixName == "twins") {
    twinsM[as.character(object), as.character(query)]
  } else {
    stop("Error in getLiteralSemantics()")
  }
}

#####
##### completeQueries()
##### ---------------------
##### add "query" words for each expt
##### this is necessary for running with rrrsa::runDf
#####
completeQueries <- function(d) {
  newD <- d
  
  currMatrix <- unique(as.character(d$matrix))
  
  
  ## meta-data
  allQueries <- c("glasses", "hat", "mustache")
  allObjects <- c("foil", "logical", "target")
  
  ## The current query
  currQuery <- unique(as.character(d$query))
  neededQueries <- setdiff(allQueries, currQuery)
  
  ## Add in new queries
  for (q in neededQueries) {
    df <- data.frame(cond = as.vector(d$cond),
                     expt = as.vector(d$expt),
                     matrix = as.vector(d$matrix),
                     prior = as.vector(d$prior),
                     query = rep(q, 3),
                     object = as.vector(d$object),
                     count = rep(NA, 3),
                     p = rep(NA, 3),
                     n = as.vector(d$n),
                     cil = rep(NA, 3), 
                     cih = rep(NA, 3),
                     priorType = as.vector(d$priorType),
                     priorValue = as.vector(d$priorValue),
                     grouper = as.vector(d$grouper))
    newD <- rbind(newD, df)
    if (currMatrix == "simple") return(newD)
  }
  newD
}
# undebug(completeQueries)
# debug(completeQueries)
# completeQueries(baserate_63)
```

## Read in data
```{r}
## This is `d` df from line 128 in sims.Rmd
d <- read.csv("data/models.csv")
# View(d)
```

## Matrices from matrices.R
```{r}
## Renamed, normalized matrices from matrices.R
simpleM <- normalizeBy(simple, rows = TRUE)
complexM <- normalizeBy(complex, rows = TRUE)
twinsM <- normalizeBy(twins, rows = TRUE)
oddmanM <- normalizeBy(oddman, rows = TRUE)
```

# Data pre-processing

NOTE:: To work with rrrsa::runDf we need each matrix to include the literal semantics of all the queries (even if they weren't actually queried)
Look at group 'baserate-63': only 'glasses' is queried, but we need to add the literal semantics for 'hat' and 'mustache' as well.
```{r}
## Initial pre-processing before adding in new cols and then adding literal semantics
processedD <- d %>%
  ## Gather priors - we're only interested in prior for current object
  gather(priorType, priorValue, c(foil, logical, target)) %>%
  ## Filter out an mismatches between current object and priorType
  filter(object == priorType) %>%
  rowwise %>%
  ## Grouping variable concatenates experiment type and sample size (expt-n)
  mutate(grouper = paste0(as.character(expt), "-", as.character(n)))

fullData <- plyr::ddply(processedD, .variables = ("grouper"), .fun = completeQueries) %>%
  rowwise %>%
  ## Each row gets a unique literal semantics from getLiteraSemantics() helper
  mutate(speaker.p = getLiteralSemantics(matrix, query = query, object = object)) %>%
  arrange(expt, n)
```

Temporarily keep: Subset run
```{r}
baserate_63 <- fullData %>% filter(grouper == "baserate-63")
rrrsa::rsa.runDf(baserate_63,
                 quantityVarName = "object", semanticsVarName = "speaker.p",
                 itemVarName = "query", priorsVarName = "priorValue")
# undebug(rrrsa::rsa.runDf)
# debug(rrrsa::rsa.runDf)
```

Temporarily keep: Tuning code
```{r}
rsaRun <- plyr::ddply(fullData, .variables = c("grouper"), rsa.runDf,
            quantityVarName = "object", semanticsVarName = "speaker.p",
            itemVarName = "query", priorsVarName = "priorValue") %>%
  rowwise %>%
  mutate(tuningData = ifelse(!is.na(count), "keep", "throwout"))
  
# keepIndices <- c("keep", "throwout")
# compareIndices  <- which(rsaRun$tuningData %in% keepIndices)
# rsaRun %>%
#   rowwise %>%
#   mutate(tuningData = ifelse(!is.na(count), "keep", "throwout"))
#   rrrsa::rsa.tuneDepthAlpha(., quantityVarName = "object", semanticsVarName = "speaker.p",
#             itemVarName = "query", priorsVarName = "priorValue", compareDataName = )
head(
  rsa.bestFit(fullData, quantityVarName = "object", semanticsVarName = "speaker.p",
              itemVarName = "query", priorsVarName = "priorValue", groupName = "grouper",
              alphas = seq(1, 5, by=0.1), depth = seq(1,3), compareDataName = "p")
)
```

# Simulations with priors (recursive depth 0-5)

## Sim data
```{r}
## Base data frame of L0
sims_prior <- plyr::ddply(fullData, .variables = c("grouper"), rsa.runDf,
            quantityVarName = "object", semanticsVarName = "speaker.p",
            itemVarName = "query", priorsVarName = "priorValue", depth = 0) %>%
  rowwise %>%
  mutate(tuningData = ifelse(!is.na(count), "keep", "throwout"),
         depth = 0) %>%
  filter(tuningData == "keep")
## Iterate through recursive depth 1 - 5
Ls <- seq(1, 5)
for (L in Ls) {
  d <- plyr::ddply(fullData, .variables = c("grouper"), rsa.runDf,
            quantityVarName = "object", semanticsVarName = "speaker.p",
            itemVarName = "query", priorsVarName = "priorValue", depth = L) %>%
  rowwise %>%
  mutate(tuningData = ifelse(!is.na(count), "keep", "throwout"),
         depth = L) %>%
  filter(tuningData == "keep")
  sims_prior <- rbind(sims_prior, d)
}

```

## Simulation plots

### Recursive depth 0-2
```{r}
sims_prior %>%
  filter(depth < 3) %>%
  ggplot(., aes(x = preds, y = p, col = expt, pch = object)) +
    geom_pointrange(aes(ymin = cil, ymax = cih)) + 
    xlim(c(0,1)) + ylim(c(0,1)) + 
    facet_wrap(~depth) +
    ylab("Proportion choosing target") + 
    xlab("Model Predictions") + 
    geom_smooth(method="lm", aes(group=1)) + 
    geom_abline(slope = 1, intercept = 0, lty=2)
```

### Recursive depth 0-5
```{r}
ggplot(sims_prior, aes(x = preds, y = p, col = expt, pch = object)) +
  geom_pointrange(aes(ymin = cil, ymax = cih)) + 
  xlim(c(0,1)) + ylim(c(0,1)) + 
  facet_wrap(~depth) +
  ylab("Proportion choosing target") + 
  xlab("Model Predictions") + 
  geom_smooth(method="lm", aes(group=1)) + 
  geom_abline(slope = 1, intercept = 0, lty=2)
```

## Correlations
```{r}
for (model in seq(0, 5)) {
  print(
    paste0("Model", model, " cor: " ,
      sims_prior %>%
        filter(depth == model) %>%
        with(., cor(p, preds))
    )
  )
}
```

## Inter-model correlations
```{r}

```

## Fitting alpha
```{r}
fullData <- fullData %>%
  rowwise %>%
  mutate(tuningData = ifelse(!is.na(count), "keep", "throwout"))
keepIndices <- c("keep", "throwout")
compareIndices  <- which(fullData$tuningData == "keep")

## Gather tuning data
aggregateTuneData <- rsa.tuneDepthAlpha(fullData, quantityVarName = "object",
                               semanticsVarName = "speaker.p", itemVarName = "query",
                               priorsVarName = "priorValue", groupName = "grouper",
                               compareDataName = "p", compareIndices = compareIndices, 
                               depth = 0, alphas = seq(1, 6, by = 0.1))
for (model in seq(1, 5)) {
  currTune <- rsa.tuneDepthAlpha(fullData, quantityVarName = "object",
                               semanticsVarName = "speaker.p", itemVarName = "query",
                               priorsVarName = "priorValue", groupName = "grouper",
                               compareDataName = "p", compareIndices = compareIndices, 
                               depth = model, alphas = seq(1, 6, by = 0.1))
  aggregateTuneData <- rbind(aggregateTuneData, currTune)
}
```

## Model performance
```{r}
## Get best model performance by alpha, depth
maxCors <- aggregateTuneData %>%
  group_by(depth) %>%
  summarize(maxCor = max(cor),
            alpha = alpha[which.max(cor)])
maxCors
```

## Plot tuning
```{r}
## Plot tuning
ggplot(aggregateTuneData, aes(x = alpha, y = cor, col = as.factor(depth))) +
  geom_point() +
  ylim(0.75, 1) +
  geom_vline(xintercept = maxCors$alpha, lty = 4, col = "grey50")
```

```{r}
# L0_alphas <- rsa.tuneDepthAlpha(fullData, quantityVarName = "object",
#                                semanticsVarName = "speaker.p", itemVarName = "query",
#                                priorsVarName = "priorValue", groupName = "grouper",
#                                compareDataName = "p", compareIndices = compareIndices, 
#                                depth = 0, alphas = seq(1, 6, by = 0.1))
# 
# L1_alphas <- rsa.tuneDepthAlpha(fullData, quantityVarName = "object",
#                                semanticsVarName = "speaker.p", itemVarName = "query",
#                                priorsVarName = "priorValue", groupName = "grouper",
#                                compareDataName = "p", compareIndices = compareIndices, 
#                                depth = 1, alphas = seq(1, 6, by = 0.1))
# 
# L2_alphas <- rsa.tuneDepthAlpha(fullData, quantityVarName = "object",
#                                semanticsVarName = "speaker.p", itemVarName = "query",
#                                priorsVarName = "priorValue", groupName = "grouper",
#                                compareDataName = "p", compareIndices = compareIndices, 
#                                depth = 2, alphas = seq(1, 6, by = 0.1))
# 
# L3_alphas <- rsa.tuneDepthAlpha(fullData, quantityVarName = "object",
#                                semanticsVarName = "speaker.p", itemVarName = "query",
#                                priorsVarName = "priorValue", groupName = "grouper",
#                                compareDataName = "p", compareIndices = compareIndices, 
#                                depth = 3, alphas = seq(1, 6, by = 0.1))
# 
# L4_alphas <- rsa.tuneDepthAlpha(fullData, quantityVarName = "object",
#                                semanticsVarName = "speaker.p", itemVarName = "query",
#                                priorsVarName = "priorValue", groupName = "grouper",
#                                compareDataName = "p", compareIndices = compareIndices, 
#                                depth = 4, alphas = seq(1, 6, by = 0.1))
# L4_alphas <- rsa.tuneDepthAlpha(fullData, quantityVarName = "object",
#                                semanticsVarName = "speaker.p", itemVarName = "query",
#                                priorsVarName = "priorValue", groupName = "grouper",
#                                compareDataName = "p", compareIndices = compareIndices, 
#                                depth = 4, alphas = seq(1, 6, by = 0.1))
# 
# debug(rsa.tuneDepthAlpha)
# undebug(rsa.tuneDepthAlpha)
#   
#   plyr::ddply(fullData, .variables = c("grouper"), rsa.runDf,
#             quantityVarName = "object", semanticsVarName = "speaker.p",
#             itemVarName = "query", priorsVarName = "priorValue", depth = 0) %>%
# 
# 
# sims_prior <- plyr::ddply(fullData, .variables = c("grouper"), rsa.runDf,
#             quantityVarName = "object", semanticsVarName = "speaker.p",
#             itemVarName = "query", priorsVarName = "priorValue", depth = 0) %>%
#   rowwise %>%
#   mutate(tuningData = ifelse(!is.na(count), "keep", "throwout"),
#          depth = 0) %>%
#   filter(tuningData == "keep")
```

